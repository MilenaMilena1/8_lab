 /*  1. strlen:
C: strlen является функцией, которая возвращает длину строки.
C++: В C++, можно использовать метод length() объекта std::string, чтобы получить длину строки.

2.strcpy:
C: strcpy копирует строку из одного массива символов в другой.
C++: В C++, можно использовать метод copy() объекта std::string, чтобы выполнить аналогичную операцию.

3.strcmp:
C: strcmp сравнивает две строки и возвращает результат сравнения.
C++: В C++, можно использовать метод compare() объекта std::string, чтобы выполнить сравнение строк.

4.strcat: 
C: strcat добавляет одну строку к другой.
C++: В C++, можно использовать оператор + для конкатенации строк std::string.

5.someString[index] (получение символа по индексу):
C: В C, вы можете получить символ из строки, обратившись к элементу массива символов.
C++: В C++, можно использовать оператор [] для получения символа по индексу из объекта std::string.

6.push_back: 
C: В C, отсутствует аналог push_back, так как строки представлены массивами символов без динамического изменения размера.
C++: push_back - это метод объекта std::string, который добавляет символ в конец строки.

7. pop_back:
C: В C, отсутствует аналог pop_back, так как строки в C не имеют встроенной поддержки для удаления символов с конца.
C++: pop_back - это метод объекта std::string, который удаляет последний символ из строки.
Главная разница между строками в C и C++ заключается в том, что строки в C++ представлены объектами класса std::string, которые обеспечивают более удобное и безопасное управление строками, 
включая автоматическое выделение и освобождение памяти, операторы для работы со строками и множество методов для выполнения операций со строками. 
В C, строки представлены массивами символов, и все операции с ними требуют более ручного управления памятью и более низкого уровня работы с данными.*/
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>

int main() {
    std::string input;
    
    // Запрос строки у пользователя
    std::cout << "Введите строку: ";
    std::getline(std::cin, input);
    
    // Удаление пробелов и пунктуационных знаков
    input.erase(std::remove_if(input.begin(), input.end(), [](char c) {
        return std::isspace(c) || std::ispunct(c);
    }), input.end());

    // Сортировка букв в алфавитном порядке
    std::sort(input.begin(), input.end());
    
    // Вывод отсортированной строки
    std::cout << "Отсортированная строка: " << input << std::endl;
    
    return 0;
}

//Задание 2
 /* 1. int *ptr = (int*)malloc(sizeof(int)):

C: Выделяет память для одного целочисленного элемента с помощью malloc.
C++: В C++ лучше использовать оператор new для выделения памяти: int *ptr = new int;. Для освобождения используйте delete ptr;.

2. int *ptrArr = (int*)malloc(sizeof(int)*N):
C: Выделяет память для массива из N целочисленных элементов с помощью malloc.
C++: В C++ можно использовать new для выделения памяти: int *ptrArr = new int[N];. Для освобождения используйте delete[] ptrArr;.

3. free(ptr):
C: Освобождает память, выделенную с помощью malloc.
C++: В C++ лучше использовать delete ptr; для освобождения.

4. free(ptrArr):
C: Освобождает память, выделенную с помощью malloc для массива.
C++: В C++ используйте delete[] ptrArr; для освобождения.
В C++, рекомендуется использовать операторы new и delete вместо malloc и free, так как они обеспечивают более безопасное управление памятью. Попытка освободить одну и ту же выделенную память дважды приведет к ошибке. 
Освободить невыделенную память также приведет к ошибке.*/
#include <iostream>

int main() {
    int numRows;
    
    // Запрос количества строк у пользователя
    std::cout << "Введите количество строк для треугольника Фибоначчи: ";
    std::cin >> numRows;

    // Выделение памяти для двумерного массива
    int **arr = new int*[numRows];
    for (int i = 0; i < numRows; ++i) {
        arr[i] = new int[i + 1];
    }

    // Заполнение массива треугольника Фибоначчи
    for (int i = 0; i < numRows; ++i) {
        for (int j = 0; j <= i; ++j) {
            if (i < 2 || j == 0 || j == i) {
                arr[i][j] = 1;
            } else {
                arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j];
            }
        }
    }

    // Вывод треугольника Фибоначчи
    for (int i = 0; i < numRows; ++i) {
        for (int j = 0; j <= i; ++j) {
            std::cout << arr[i][j] << " ";
        }
        std::cout << std::endl;
    }

    // Освобождение памяти
    for (int i = 0; i < numRows; ++i) {
        delete[] arr[i];
    }
    delete[] arr;

    return 0;
}